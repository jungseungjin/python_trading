# DataFrame 생성
# 판다스의 Series가 1차원 데이터를 저장한다면, DataFrame은 가로축과 세로축이 있는 2차원 데이터를 저장하는 자료구조입니다. 
# 클래스로 pandas 모듈 안에 구현되어 있기 때문에, 이를 이용하기 위해서는 우선 import를 해야 합니다.

from pandas import DataFrame

# DataFrame 객체는 딕셔너리를 사용해서 만들 수 있습니다. 
# 클래스 DataFrame의 생성자로 딕셔너리를 넘겨주면 DataFrame 객체가 만들어집니다.

# 1: data = {'open': [100, 200], "high": [110, 210]} 
# 2: df = DataFrame(data ) 
# 3: print(df)
# 라인 1: data라는 변수는 파이썬 딕셔너리를 바인딩합니다.
# 라인 2: DataFrame 객체가 생성되고 df 변수에 바인딩합니다.
# 라인 3: df라는 변수가 바인딩하는 객체의 타입을 출력합니다.


# 위 코드를 실행하면 두 개의 열과 두 개의 행으로 구성된 DataFrame 객체를 확인할 수 있습니다. 인덱스는 0부터 순차 증가하는 숫자로 자동 맵핑되었습니다.

#    open  high
# 0   100   110
# 1   200   210



# DataFrame 객체를 생성할 때, index 파라미터로 날짜 (문자열 리스트)를 넘겨줍니다. Series에서 index를 추가하는 것과 같죠?

# # ch04/04_17.py
# data = {"open": [737, 750], "high": [755, 780], "low": [700, 710], "close": [750, 770]} 
# df = DataFrame(data , index=["2018-01-01", "2018-01-02"]) 
# print(df)
# 위 코드를 실행하면 DataFrame 객체가 문자열 인덱스와 함께 출력됩니다.

#             open  high  low  close
# 2018-01-01   737   755  700    750
# 2018-01-02   750   780  710    770

# 지금까지 딕셔너리를 사용해서 DataFrame을 만드는 방법에 대해 배웠는데, 
# 이것은 DataFrame을 연습하기 위한 예제에 가깝습니다. 
# 일반적으로 파일 혹은 웹페이지 등에 데이터가 저장되어 있습니다. 
# DataFrame은 사용자 편의를 위해 파일 혹은 웹페이지에 저장된 데이터를 가져오는 함수를 제공합니다.

""""
엑셀 읽기
""""

# 우선 엑셀 파일을 읽어 DataFrame 객체를 생성하는 방법을 알아보겠습니다. 
# 엑셀 프로그램을 켜고 Sheet에 그림 4-28과 같이 데이터를 입력하세요. 
# 작성한 후에는 엑셀 파일을 저장하고 저장 경로를 복사하세요. 예제에서는 "C:\ohlc.xlsx"에 저장했습니다.

# 판다스가 제공하는 read_excel 함수는 엑셀 파일을 읽어 DataFrame 객체로 변환합니다.

# # ch04/04_18.py
# 1: import pandas as pd 
# 2: df = pd.read_excel("C:\\ohlc.xlsx") 
# 3: print(df)
# 라인 1: pandas 모듈을 pd라는 이름으로 선언합니다.
# 라인 2: pd의 read_excel 함수가 엑셀을 읽고 DataFrame으로 변환해서 반환합니다.
# 라인 3: df에 바인딩된 DataFrame 객체를 출력합니다.


# 예제에서는 데이터가 세 라인밖에 없지만, 실제 엑셀 시트에는 수백, 수천 개의 데이터가 저장되어 있을 겁니다. 데이터를 매번 딕셔너리로 만든 후, DataFrame으로 생성하는 것은 시간 소모적인 일일 수밖에 없습니다.

#          date  open  high  low  close
# 0 2018-01-01   100   110   70    100
# 1 2018-01-02   200   210  180    190
# 2 2018-01-03   300   310  300    310
# 엑셀에서 읽은 DataFrame은 기본적으로 자동 맵핑된 행 번호를 사용합니다. 자동 생성된 번호 대신 다른 Column을 index로 지정하기 위해서는 set_index 함수를 사용합니다. 함수의 파라미터로 Column 이름을 넘기면 해당하는 Column이 index로 변환됩니다. set_index 함수는 원본 DataFrame 객체는 그대로 두고 index를 변경한 DataFrame 객체를 반환해줍니다. 따라서 set_index 함수의 결과를 df 변수에 다시 바인딩해야 합니다.

# 1: df = df.set_index('date')
# 2: print(df)
#        date  open  high  low  close 
# 2018-01-01 100   110   70   100 
# 2018-01-02 200   210   180  190 
# 2018-01-03 300   310   300  310
# DataFrame 객체를 엑셀로 저장 할때는 DataFrame의 to_excel 메서드를 사용합니다. 다음 코드는 C 드라이브의 ohlc-2.xlsx 이름의 엑셀 파일로 DataFrame 객체를 저장하는 예제입니다.

# # ch04/04_19.py
# 1: df.to_excel("C:\\ohlc-2.xlsx")
# 읽을 때는 read_excel 함수, 쓸 때는 to_excel 함수를 사용합니다. 함수 이름이 직관적이라 기억하기 쉽죠?

""""
HTML파싱하기 - table태그에서 값을 가져옴
"""

# pandas 모듈의 read_html() 함수는 웹페이지를 DataFrame으로 변환합니다. 웹페이지 주소를 함수의 파라미터로 전달하면 DataFrame 객체를 반환합니다.

# # ch04/04_20.py
# 1: import pandas as pd 
# 2: url = "https://finance.naver.com/item/sise_day.nhn?code=066570" 
# 3: df = pd.read_html(url) 
# 4: print(df[0])
# 4.1 장의 웹 스크래핑에서 웹페이지의 데이터는 HTML로 표현된다고 배웠지요? read_html() 함수는 웹페이지의 HTML을 다운받고 <table> 태그를 파싱해서 DataFrame으로 변경합니다. 웹 페이지에 여러 개의 <table>이 있을 수 있기 때문에 read_html 함수는 결괏값으로 DataFrame의 리스트를 반환합니다.

# 아래는 df[0]을 화면에 출력한 결과입니다. 엑셀에서 데이터를 읽을 때와 동일하게 자동으로 맵핑된 인덱스가 사용되었습니다.

#              0      1     2      3      4      5        6
# 0         날짜   종가 전일비  시가   고가   저가    거래량
# 1          NaN    NaN   NaN    NaN    NaN    NaN      NaN
# 2   2018.08.17  72400   900  74100  74100  72400   843950
# 3   2018.08.16  73300   300  72500  73900  71300   920959
# 4   2018.08.14  73600  2700  76100  76200  70900  2397515
# 5   2018.08.13  76300  2700  78200  78400  75800   840750
# 6   2018.08.10  79000  1400  80000  80700  78700   961866
#     ( ... 생략 ... )
# NaN은 네이버 금융 페이지의 HTML Table에 숨겨진 코드 때문에 출력되며 dropna 함수를 사용해서 행을 제거할 수 있습니다. 파라미터로 axis 값을 전달하는데 0일 경우 행을 삭제하며, 1일 경우 열을 삭제합니다. 다음 코드에서 axis 값으로 0을 지정했기 때문에 NaN이 포함된 행 전체를 삭제한 것을 확인할 수 있습니다.

# print(df[0].dropna(axis=0))
#              0      1     2      3      4      5        6
# 0         날짜   종가 전일비  시가   고가   저가    거래량
# 2   2018.08.17  72400   900  74100  74100  72400   843950
# 3   2018.08.16  73300   300  72500  73900  71300   920959
# 4   2018.08.14  73600  2700  76100  76200  70900  2397515
# 5   2018.08.13  76300  2700  78200  78400  75800   840750
# 6   2018.08.10  79000  1400  80000  80700  78700   961866


'''
DataFrame 인덱싱/슬라이싱
'''

# DataFrame은 가로축과 세로축이 있는 이차원 형태의 자료구조이기 때문에 행, 열의 데이터를 얻어올 방법을 모두 사용할 수 있어야 합니다. 
# 먼저 열 단위로 데이터를 가져오는 방법을 알아보겠습니다. 
# df 변수에는 표 4-7에 해당하는 OHLC가 DataFrame으로 저장되어 있다고 가정합시다.

# 표 4-7 이틀 동안의 OHLC 데이터

# -	OPEN	HIGH	LOW	CLOSE
# 2018-01-01	730	755	700	750
# 2018-01-02	750	780	710	770
# 딕셔너리 key를 사용해서 값에 접근하는 것과 같이 DataFrame의 열 이름을 사용해서 하나의 열을 가져옵니다. 이때 가져온 데이터는 Series입니다.

# # ch04/04_21.py
# 1: data = {"open": [730, 750], "high": [755, 780], "low": [700, 710], "close": [750, 770]} 
# 2: df = DataFrame(data , index=["2018-01-01", "2018-01-02"]) 
# 3: print(df['open'])
# 2018-01-01    737
# 2018-01-02    750
# Name: open, dtype: int64
# 이번에는 ‘2018-01-01’ 일자의 OHLC (하나의 행)를 가져와 봅시다. DataFrame은 loc라는 특수한 메서드를 사용해서 하나의 행을 가져올 수 있습니다. loc 메서드에 특정 인덱스를 넘겨주면 해당하는 행의 데이터가 Series로 반환됩니다. 코드의 실행 결과 "2018-01-01" 인덱스를 갖는 OHLC 행이 출력된 것을 확인할 수 있습니다.

# # ch04/04_22.py
# # 생략
# 3: print(df.loc["2018-01-01"])
# Open      730 
# High       755 
# Low        700 
# Close      750 
# Name: 2018-01-01, dtype: int64
# 인덱스가 없을 경우는 어떻게 해야 할까요? iloc 메서드를 사용하면 자동으로 맵핑되는 숫자 index로 값을 얻어올 수 있습니다. 다음 코드의 실행 결과는 loc["2018-01-01"] 코드를 실행한 결과와 동일합니다.

# print(df.iloc[0])
# DataFrame 객체에서 행을 가져올 때 loc나 iloc를 사용할 수 있는데 상황에 따라 적절한 메서드를 호출하는 것이 중요합니다. 예를 들어 2018-04월의 일봉 데이터가 DataFrame 객체로 저장되어 있을 때 첫 번째 거래일의 일봉 데이터를 얻어와야 하는 경우를 생각해봅시다. 만약 날짜를 이용해서 첫 번째 거래일의 데이터를 얻어오려면 먼저 2018-04월의 첫 번째 거래일을 알아야 하는데 이는 쉬운 일이 아닙니다. 참고로 4월 1일은 일요일이어서 첫 번째 거래일은 4월 2일입니다. 이런 경우에는 iloc[0]을 사용해서 행 데이터를 가져가는 편이 좋습니다.

# 하나 이상의 행을 가져올 때는 리스트에 인덱스를 넣고, 리스트를 loc로 전달하면 됩니다. 아래 코드는 loc를 사용해서 2018-01-01, 2018-01-02 이틀의 OHLC 값을 가져옵니다.

# target = ["2018-01-01", "2018-01-02"]
# print(df.loc[target])
# iloc를 사용해서 앞서 사용한 loc와 동일한 결과를 얻을 수도 있습니다.

# target = [0, 1] 
# print(df.iloc[target])

"""""
# DataFrame 추가하기
"""""

# 미리 생성된 DataFrame에 새로운 Column을 추가할 수도 있습니다. 딕셔너리에 값을 추가하는 것처럼 Column의 이름을 키값으로 지정하고 우변에는 Series 객체를 사용하면 됩니다.

# # ch04/04_23.py
# 1: data = {"open": [737, 750], "high": [755, 780], "low": [700, 710], "close": [750, 770]} 
# 2: df = DataFrame(data) 
# 3: s = Series([300, 400]) 
# 4: df['volume'] = s 
# 5: print(df)
# 라인 3: DataFrame에 추가할 Series 객체를 생성합니다.
# 라인 4: DataFrame에 volume이란 이름으로 Series 객체를 추가합니다.


# 출력값을 살펴보면 volume 열이 추가된 것을 확인할 수 있습니다.

#    open  high  low  close  volume
# 0   737   755  700    750     300
# 1   750   780  710    770     400
# 행을 추가할 때는 loc를 사용해서 행의 이름과 데이터를 튜플 혹은 리스트로 넘겨주면 됩니다. 아래 코드는 2라는 이름의 행에 (100, 200, 300, 400, 500)의 값을 추가합니다. 데이터의 개수가 DataFrame 행의 데이터 개수와 동일해야 함에 주의하세요.

# 1: df.loc[2] = (100, 200, 300, 400, 500) 
# 2: print(df)
# DataFrame을 사용할 때 Series를 새롭게 생성해서 데이터를 추가하는 것보다는 기존 데이터를 활용해서 데이터를 추가하는 일이 빈번하게 일어납니다. 다음 코드를 살펴봅시다.

# # ch04/04_24.py
# 1: upper = df[“open”] * 1.3
# 2: df[“upper”] = upper
# 라인 1: DataFrame에서 open 이름의 열을 Series로 가져옵니다. open 열에 저장된 Series에 1.3을 모두 곱하고 upper 변수에 바인딩합니다.
# 라인 2: DataFrame에 upper 이름의 열을 추가합니다.


# 인덱싱의 결과가 Series였음을 기억해야 합니다. Series 타입이기 때문에 곱하기 연산이 모든 데이터에 적용되고 그 결과 역시 Series입니다. 위 코드를 실행한 결과 df 변수에 upper 열이 추가된 것을 확인할 수 있습니다.

#                 open  high  low  close  upper
# 2018-01-01   737   755  700    750  958.1
# 2018-01-02   750   780  710    770  975.0

"""""
칼럼 시프트
"""""
# 그림 4-29의 엑셀과 같이 A 칼럼에 100, 200, 300이 있는데 이를 한 줄 내려서 B 칼럼에 저장하는 경우를 생각해 봅시다. 이때 1번째 행에는 데이터가 없을 것이고 300의 값은 B 칼럼에서 삭제가 되면 됩니다. 엑셀에서는 영역을 선택한 후 복사 붙여 넣기 하면 쉽게 데이터를 조작할 수 있지요?



# 그림 4-29 시프트된 B 열


# 그렇다면 Pandas에서는 이를 어떻게 해야 할까요? Series 객체 있는 값을 시프트 하기 위해서는 shift 메서드를 사용합니다. shift(1)이라고 호출하면 값을 하나 내려줍니다.

# # ch04/04_25.py
# 1: from pandas import Series 
# 2: 
# 3: s = Series([100, 200, 300]) 
# 4: s2 = s.shift(1) 
# 5: print(s) 
# 6: print(s2)
# 실행 결과를 살펴보면 s가 바인딩하는 Series 객체의 값이 하나씩 밑으로 내려가 있는 것을 확인할 수 있습니다.

# 0    100
# 1    200
# 2    300
# dtype: int64
# 0      NaN
# 1    100.0
# 2    200.0
# dtype: float64
# 참고로 위쪽으로 값을 올려주려면 shift(-1)을 해주면 됩니다.

# 1: from pandas import Series 
# 2: 
# 3: s = Series([100, 200, 300]) 
# 4:s2 = s.shift(-1) 
# 5: print(s) 
# 6: print(s2)